## Keyspace Definition
Defined a keyspace ```retail``` with the ```NetworkTopologyStrategy```. This strategy will allow growth as operations are spun up and additional data centers are brought online. Initially we have a single DC, ```Cassandra```, defined with a replication factor of 3 per requirements.


## Brands Table
Initial requirements indicating purely storing a brand's name. The table contains a single column ```name``` which also serves as the primary key.


## Products Table
This table contains metadata information around products. A product is identified by a C* generated TIMEUUID value. Should the customer provide their own id value we can update the type to match and store their value instead. This value currently functions as the primary key. Lookups for products **require** this value.

There is a direct relation to the brand table. The brand name is duplicated. Depending on access patterns there may be future tables such as ```products_by_brand``` which would allow surfacing all products for a given brand. This has been omitted from model as it is not currently a requirement.

The products table may be expanded in the future to support multiple prices per product. This can be due to variations in currency. Changes in price over time may also be stored in this table. This would allow looking up a price for a product on any given day.

Consider creating a tax category column. This could be matched with values in the ```tax_rates``` map on ```store```.

Depending on the query patterns for this table (and related sub-tables) we would shift primary key columns and potentially add extra columns.

**Derived Tables**

* products_by_brand
* products_by_region
* products_by_title


## Stores Table
```stores``` reflects metadata surrounding a single physical store. Each store is identified by a unique C* generated TIMEUUID value. Should the customer provide their own id value we can update the type to match and store their value instead. This value currently functions as the primary key. Lookups for stores **require** this value.

Phone number information is stored in a map. This relates phone numbers with their role in the store (pharmacy, department, fax, etc). 

Hours is also a map, with the key representing the day of week and the value being a range of hours (in text format ```Monday```: ```8AM-10PM```).

Register counts are stored as integers. Since we are not querying on these value they could be stored in a map. The type of register (full, express, self-checkout, etc) would map to the number present. This would also allow expansion in the future to any number of register types.

Tax rate is modeled with a map value. This allows a variety of tax rates to be stored according to regulatory requirements.

**Derived Tables**

* stores_by_region
* stores_by_district


## Employees
Each employee is identified by a unique C* generated TIMEUUID value. Should the customer provide their own id value we can update the type to match and store their value instead. This value currently functions as the primary key. Lookups for employees **require** this value.

**Derived Tables**

* employees_by_name_and_last_initial
* employees_by_store


## Registers
Consider renaming this value to represent the values stored. "Registers" has specific meaning within the retail space and this may cause confusion. To avoid confusion we will refer to register rows as "line items".

This table stores line item transactions generated by scanning a product. All items purchased are tied together by ```receipt_id``` for the entire transaction.

Metadata around the store, district, and region is present to facilitate the creation of derived tables.

The line item is linked with a product by the product's id. We may duplicate some product information here to track both changes in product information over time and to avoid subsequent reads.

Within our data model we are referencing the price as a map of text to double. The text component describes the type of price stored (msrp, sale) with the double holding the actual price value. It should be noted that we are not storing the savings value as this can be derived from sales price and msrp.

Scan time needs further definition. Is this a timestamp that reflects the exact time when the product was scanned *or* is it the duration of time it took to scan this item.

**Derived Tables**

* registers_by_receipt
* registers_by_date_hour
* registers_by_region_product (rollup table)
* registers_by_district_product (rollup table)
* registers_by_store_product (rollup table)

## Receipts
Each receipt is identified by a unique C* generated TIMEUUID value. Should the customer provide their own id value we can update the type to match and store their value instead. This value currently functions as the primary key. Lookups for receipts **require** this value.

Metadata around the store, district, and region is present to facilitate the creation of derived tables.

The employee operating the register (physical reference not data model), is recorded as the cashier. Here we are storing their id, but additional information may be added to reduce subsequent queries to the employees table.

```drawer_closing_time``` is represented as a timestamp. This is the moment the payment has been processed and the transaction complete.

```total``` represents the total costs of all items including applicable taxes.

```payment``` is modeled as a map. The payment source (cash, credit card, debit card, etc) and value for that particular source. This allows tracking multiple forms of payment on a single receipt.

**Derived Tables**

* receipts_by_region (rollup table)
* receipts_by_district (rollup table)
* receipts_by_store (rollup table)
* receipts_by_cashier 
* receipts_by_date_hour


## Receipts & Registers
There is a possible data model where receipts and registers are collapsed into a single table. The primary key may be partitioned on receipt_id and clustered on register_id. Values related to the receipt may be stored as static columns keeping the duplication of those values to a minimum.

Similar derived tables from both Registers and Receipts may be built from this table.


# Analytics & Query Access Based Tables
With this model we have distilled our data down to distinct chunks of information. As query access patterns are defined we can build new tables to support them. Spark may be used to populate data from the current model into the specialized derived tables.

We may find as the project goes on that the simple versions of these tables are no longer needed and the access based tables provide all of the data required.

## Examples of analytic queries include:

Which items take the longest to scan

Use a spark job to calculate deltas between successive scans on the same receipt.  From this resultset, group by item and report average and 99 %-ile scan times.  Produce pre-computed or on-demand reports sorted by average/99%ile scan times, with a "top-n" filter

Which products are sold more in specific regions

Again, we would use an analytic tool like Spark to process data in the registers table, grouping by product, and calculating deltas compared to a reference region.  Sort by absolute or percentage differences





